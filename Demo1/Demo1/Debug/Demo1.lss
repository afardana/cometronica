
Demo1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000cc0  00000d54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cc0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000062f  00800110  00800110  00000d64  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00000d64  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000010b  00000000  00000000  000014b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000015bf  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  000015ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002b48  00000000  00000000  00001866  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ad6  00000000  00000000  000043ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000019dc  00000000  00000000  00004e84  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000006d8  00000000  00000000  00006860  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000c34  00000000  00000000  00006f38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000024c2  00000000  00000000  00007b6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000002a0  00000000  00000000  0000a02e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	dd c2       	rjmp	.+1466   	; 0x5ec <__vector_12>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 ec       	ldi	r30, 0xC0	; 192
  a0:	fc e0       	ldi	r31, 0x0C	; 12
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 31       	cpi	r26, 0x10	; 16
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	a0 e1       	ldi	r26, 0x10	; 16
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	af 33       	cpi	r26, 0x3F	; 63
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	22 d0       	rcall	.+68     	; 0x108 <main>
  c4:	fb c5       	rjmp	.+3062   	; 0xcbc <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <vLEDTask2>:
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
	}
}

void vLEDTask2()
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	00 d0       	rcall	.+0      	; 0xce <vLEDTask2+0x6>
  ce:	cd b7       	in	r28, 0x3d	; 61
  d0:	de b7       	in	r29, 0x3e	; 62
	vLEDInit();
  d2:	7a d0       	rcall	.+244    	; 0x1c8 <vLEDInit>
	portTickType xLastWakeTime;
	xLastWakeTime = xTaskGetTickCount();
  d4:	f8 d3       	rcall	.+2032   	; 0x8c6 <xTaskGetTickCount>
  d6:	9a 83       	std	Y+2, r25	; 0x02
  d8:	89 83       	std	Y+1, r24	; 0x01

	const portTickType xFrequency = 500;
	while (1)
	{
		vLED2Toggle();
  da:	7e d0       	rcall	.+252    	; 0x1d8 <vLED2Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
  dc:	64 ef       	ldi	r22, 0xF4	; 244
  de:	71 e0       	ldi	r23, 0x01	; 1
  e0:	ce 01       	movw	r24, r28
  e2:	01 96       	adiw	r24, 0x01	; 1
  e4:	50 d5       	rcall	.+2720   	; 0xb86 <vTaskDelayUntil>
  e6:	f9 cf       	rjmp	.-14     	; 0xda <vLEDTask2+0x12>

000000e8 <vLEDTask1>:

	return 0;
}

void vLEDTask1()
{
  e8:	cf 93       	push	r28
  ea:	df 93       	push	r29
  ec:	00 d0       	rcall	.+0      	; 0xee <vLEDTask1+0x6>
  ee:	cd b7       	in	r28, 0x3d	; 61
  f0:	de b7       	in	r29, 0x3e	; 62
	vLEDInit();
  f2:	6a d0       	rcall	.+212    	; 0x1c8 <vLEDInit>
	portTickType xLastWakeTime;
	xLastWakeTime = xTaskGetTickCount();
  f4:	e8 d3       	rcall	.+2000   	; 0x8c6 <xTaskGetTickCount>
  f6:	9a 83       	std	Y+2, r25	; 0x02
  f8:	89 83       	std	Y+1, r24	; 0x01

	const portTickType xFrequency = 1000;
	while (1)
	{
		vLEDToggle();
  fa:	69 d0       	rcall	.+210    	; 0x1ce <vLEDToggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
  fc:	68 ee       	ldi	r22, 0xE8	; 232
  fe:	73 e0       	ldi	r23, 0x03	; 3
 100:	ce 01       	movw	r24, r28
 102:	01 96       	adiw	r24, 0x01	; 1
 104:	40 d5       	rcall	.+2688   	; 0xb86 <vTaskDelayUntil>
 106:	f9 cf       	rjmp	.-14     	; 0xfa <vLEDTask1+0x12>

00000108 <main>:

void vLEDTask1();
void vLEDTask2();

int main()
{
 108:	af 92       	push	r10
 10a:	bf 92       	push	r11
 10c:	cf 92       	push	r12
 10e:	df 92       	push	r13
 110:	ef 92       	push	r14
 112:	ff 92       	push	r15
 114:	0f 93       	push	r16
	xTaskCreate( vLEDTask1, ( const char * ) "LED", configMINIMAL_STACK_SIZE, NULL, LEDTaskPriority, NULL );
 116:	a1 2c       	mov	r10, r1
 118:	b1 2c       	mov	r11, r1
 11a:	c1 2c       	mov	r12, r1
 11c:	d1 2c       	mov	r13, r1
 11e:	e1 2c       	mov	r14, r1
 120:	f1 2c       	mov	r15, r1
 122:	01 e0       	ldi	r16, 0x01	; 1
 124:	20 e0       	ldi	r18, 0x00	; 0
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	45 e5       	ldi	r20, 0x55	; 85
 12a:	50 e0       	ldi	r21, 0x00	; 0
 12c:	62 e0       	ldi	r22, 0x02	; 2
 12e:	71 e0       	ldi	r23, 0x01	; 1
 130:	84 e7       	ldi	r24, 0x74	; 116
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	9a d2       	rcall	.+1332   	; 0x66a <xTaskGenericCreate>
	xTaskCreate( vLEDTask2, ( const char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, LEDTaskPriority, NULL );
 136:	20 e0       	ldi	r18, 0x00	; 0
 138:	30 e0       	ldi	r19, 0x00	; 0
 13a:	45 e5       	ldi	r20, 0x55	; 85
 13c:	50 e0       	ldi	r21, 0x00	; 0
 13e:	66 e0       	ldi	r22, 0x06	; 6
 140:	71 e0       	ldi	r23, 0x01	; 1
 142:	84 e6       	ldi	r24, 0x64	; 100
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	91 d2       	rcall	.+1314   	; 0x66a <xTaskGenericCreate>
	
	// Start task scheduler
	vTaskStartScheduler();
 148:	8f d3       	rcall	.+1822   	; 0x868 <vTaskStartScheduler>

	return 0;
}
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	0f 91       	pop	r16
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	bf 90       	pop	r11
 15a:	af 90       	pop	r10
 15c:	08 95       	ret

0000015e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 15e:	cf 93       	push	r28
 160:	df 93       	push	r29
 162:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 164:	aa d3       	rcall	.+1876   	; 0x8ba <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 166:	80 91 10 01 	lds	r24, 0x0110
 16a:	90 91 11 01 	lds	r25, 0x0111
 16e:	89 2b       	or	r24, r25
 170:	31 f4       	brne	.+12     	; 0x17e <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 172:	83 e1       	ldi	r24, 0x13	; 19
 174:	91 e0       	ldi	r25, 0x01	; 1
 176:	90 93 11 01 	sts	0x0111, r25
 17a:	80 93 10 01 	sts	0x0110, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 17e:	40 91 ee 06 	lds	r20, 0x06EE
 182:	50 91 ef 06 	lds	r21, 0x06EF
 186:	9e 01       	movw	r18, r28
 188:	24 0f       	add	r18, r20
 18a:	35 1f       	adc	r19, r21
 18c:	2b 3d       	cpi	r18, 0xDB	; 219
 18e:	85 e0       	ldi	r24, 0x05	; 5
 190:	38 07       	cpc	r19, r24
 192:	70 f4       	brcc	.+28     	; 0x1b0 <pvPortMalloc+0x52>
 194:	42 17       	cp	r20, r18
 196:	53 07       	cpc	r21, r19
 198:	70 f4       	brcc	.+28     	; 0x1b6 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 19a:	c0 91 10 01 	lds	r28, 0x0110
 19e:	d0 91 11 01 	lds	r29, 0x0111
 1a2:	c4 0f       	add	r28, r20
 1a4:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
 1a6:	30 93 ef 06 	sts	0x06EF, r19
 1aa:	20 93 ee 06 	sts	0x06EE, r18
 1ae:	05 c0       	rjmp	.+10     	; 0x1ba <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 1b0:	c0 e0       	ldi	r28, 0x00	; 0
 1b2:	d0 e0       	ldi	r29, 0x00	; 0
 1b4:	02 c0       	rjmp	.+4      	; 0x1ba <pvPortMalloc+0x5c>
 1b6:	c0 e0       	ldi	r28, 0x00	; 0
 1b8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
 1ba:	69 d4       	rcall	.+2258   	; 0xa8e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 1bc:	8c 2f       	mov	r24, r28
 1be:	9d 2f       	mov	r25, r29
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1c6:	08 95       	ret

000001c8 <vLEDInit>:

#include <avr/io.h>

void vLEDInit()
{
	DDRB = ( 1<<DDB1 | 1<<DDB0 ); // Sama dengan DDRB = 0b00000001;
 1c8:	83 e0       	ldi	r24, 0x03	; 3
 1ca:	87 bb       	out	0x17, r24	; 23
 1cc:	08 95       	ret

000001ce <vLEDToggle>:
	//PORTB &= ~( 1<<PB0 ); // Mematikan pull-up pada PORTB PIN0
}

void vLEDToggle()
{
	PORTB ^= ( 1<<PB0 ); // Membalik kondisi PB0
 1ce:	98 b3       	in	r25, 0x18	; 24
 1d0:	81 e0       	ldi	r24, 0x01	; 1
 1d2:	89 27       	eor	r24, r25
 1d4:	88 bb       	out	0x18, r24	; 24
 1d6:	08 95       	ret

000001d8 <vLED2Toggle>:
}

void vLED2Toggle()
{
	PORTB ^= ( 1<<PB1 ); // Membalik kondisi PB1
 1d8:	98 b3       	in	r25, 0x18	; 24
 1da:	82 e0       	ldi	r24, 0x02	; 2
 1dc:	89 27       	eor	r24, r25
 1de:	88 bb       	out	0x18, r24	; 24
 1e0:	08 95       	ret

000001e2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 1e2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1e4:	03 96       	adiw	r24, 0x03	; 3
 1e6:	92 83       	std	Z+2, r25	; 0x02
 1e8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 1ea:	2f ef       	ldi	r18, 0xFF	; 255
 1ec:	3f ef       	ldi	r19, 0xFF	; 255
 1ee:	34 83       	std	Z+4, r19	; 0x04
 1f0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1f2:	96 83       	std	Z+6, r25	; 0x06
 1f4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1f6:	90 87       	std	Z+8, r25	; 0x08
 1f8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 1fa:	10 82       	st	Z, r1
 1fc:	08 95       	ret

000001fe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 1fe:	fc 01       	movw	r30, r24
 200:	11 86       	std	Z+9, r1	; 0x09
 202:	10 86       	std	Z+8, r1	; 0x08
 204:	08 95       	ret

00000206 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	9c 01       	movw	r18, r24
 20c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 20e:	dc 01       	movw	r26, r24
 210:	11 96       	adiw	r26, 0x01	; 1
 212:	cd 91       	ld	r28, X+
 214:	dc 91       	ld	r29, X
 216:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 218:	d3 83       	std	Z+3, r29	; 0x03
 21a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 21c:	8c 81       	ldd	r24, Y+4	; 0x04
 21e:	9d 81       	ldd	r25, Y+5	; 0x05
 220:	95 83       	std	Z+5, r25	; 0x05
 222:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 224:	8c 81       	ldd	r24, Y+4	; 0x04
 226:	9d 81       	ldd	r25, Y+5	; 0x05
 228:	dc 01       	movw	r26, r24
 22a:	13 96       	adiw	r26, 0x03	; 3
 22c:	7c 93       	st	X, r23
 22e:	6e 93       	st	-X, r22
 230:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 232:	7d 83       	std	Y+5, r23	; 0x05
 234:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 236:	31 87       	std	Z+9, r19	; 0x09
 238:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 23a:	f9 01       	movw	r30, r18
 23c:	80 81       	ld	r24, Z
 23e:	8f 5f       	subi	r24, 0xFF	; 255
 240:	80 83       	st	Z, r24
}
 242:	df 91       	pop	r29
 244:	cf 91       	pop	r28
 246:	08 95       	ret

00000248 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 248:	cf 93       	push	r28
 24a:	df 93       	push	r29
 24c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 24e:	48 81       	ld	r20, Y
 250:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 252:	4f 3f       	cpi	r20, 0xFF	; 255
 254:	2f ef       	ldi	r18, 0xFF	; 255
 256:	52 07       	cpc	r21, r18
 258:	21 f4       	brne	.+8      	; 0x262 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 25a:	fc 01       	movw	r30, r24
 25c:	a7 81       	ldd	r26, Z+7	; 0x07
 25e:	b0 85       	ldd	r27, Z+8	; 0x08
 260:	0d c0       	rjmp	.+26     	; 0x27c <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 262:	dc 01       	movw	r26, r24
 264:	13 96       	adiw	r26, 0x03	; 3
 266:	01 c0       	rjmp	.+2      	; 0x26a <vListInsert+0x22>
 268:	df 01       	movw	r26, r30
 26a:	12 96       	adiw	r26, 0x02	; 2
 26c:	ed 91       	ld	r30, X+
 26e:	fc 91       	ld	r31, X
 270:	13 97       	sbiw	r26, 0x03	; 3
 272:	20 81       	ld	r18, Z
 274:	31 81       	ldd	r19, Z+1	; 0x01
 276:	42 17       	cp	r20, r18
 278:	53 07       	cpc	r21, r19
 27a:	b0 f7       	brcc	.-20     	; 0x268 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 27c:	12 96       	adiw	r26, 0x02	; 2
 27e:	ed 91       	ld	r30, X+
 280:	fc 91       	ld	r31, X
 282:	13 97       	sbiw	r26, 0x03	; 3
 284:	fb 83       	std	Y+3, r31	; 0x03
 286:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 288:	d5 83       	std	Z+5, r29	; 0x05
 28a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 28c:	bd 83       	std	Y+5, r27	; 0x05
 28e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 290:	13 96       	adiw	r26, 0x03	; 3
 292:	dc 93       	st	X, r29
 294:	ce 93       	st	-X, r28
 296:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 298:	99 87       	std	Y+9, r25	; 0x09
 29a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 29c:	fc 01       	movw	r30, r24
 29e:	20 81       	ld	r18, Z
 2a0:	2f 5f       	subi	r18, 0xFF	; 255
 2a2:	20 83       	st	Z, r18
}
 2a4:	df 91       	pop	r29
 2a6:	cf 91       	pop	r28
 2a8:	08 95       	ret

000002aa <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 2aa:	cf 93       	push	r28
 2ac:	df 93       	push	r29
 2ae:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 2b0:	a0 85       	ldd	r26, Z+8	; 0x08
 2b2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2b4:	c2 81       	ldd	r28, Z+2	; 0x02
 2b6:	d3 81       	ldd	r29, Z+3	; 0x03
 2b8:	84 81       	ldd	r24, Z+4	; 0x04
 2ba:	95 81       	ldd	r25, Z+5	; 0x05
 2bc:	9d 83       	std	Y+5, r25	; 0x05
 2be:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 2c0:	c4 81       	ldd	r28, Z+4	; 0x04
 2c2:	d5 81       	ldd	r29, Z+5	; 0x05
 2c4:	82 81       	ldd	r24, Z+2	; 0x02
 2c6:	93 81       	ldd	r25, Z+3	; 0x03
 2c8:	9b 83       	std	Y+3, r25	; 0x03
 2ca:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 2cc:	11 96       	adiw	r26, 0x01	; 1
 2ce:	cd 91       	ld	r28, X+
 2d0:	dc 91       	ld	r29, X
 2d2:	12 97       	sbiw	r26, 0x02	; 2
 2d4:	ce 17       	cp	r28, r30
 2d6:	df 07       	cpc	r29, r31
 2d8:	31 f4       	brne	.+12     	; 0x2e6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 2da:	8c 81       	ldd	r24, Y+4	; 0x04
 2dc:	9d 81       	ldd	r25, Y+5	; 0x05
 2de:	12 96       	adiw	r26, 0x02	; 2
 2e0:	9c 93       	st	X, r25
 2e2:	8e 93       	st	-X, r24
 2e4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 2e6:	11 86       	std	Z+9, r1	; 0x09
 2e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 2ea:	8c 91       	ld	r24, X
 2ec:	81 50       	subi	r24, 0x01	; 1
 2ee:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 2f0:	df 91       	pop	r29
 2f2:	cf 91       	pop	r28
 2f4:	08 95       	ret

000002f6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2f6:	31 e1       	ldi	r19, 0x11	; 17
 2f8:	fc 01       	movw	r30, r24
 2fa:	30 83       	st	Z, r19
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	22 e2       	ldi	r18, 0x22	; 34
 300:	20 83       	st	Z, r18
 302:	fc 01       	movw	r30, r24
 304:	32 97       	sbiw	r30, 0x02	; 2
 306:	a3 e3       	ldi	r26, 0x33	; 51
 308:	a0 83       	st	Z, r26
 30a:	fc 01       	movw	r30, r24
 30c:	33 97       	sbiw	r30, 0x03	; 3
 30e:	60 83       	st	Z, r22
 310:	fc 01       	movw	r30, r24
 312:	34 97       	sbiw	r30, 0x04	; 4
 314:	70 83       	st	Z, r23
 316:	fc 01       	movw	r30, r24
 318:	35 97       	sbiw	r30, 0x05	; 5
 31a:	10 82       	st	Z, r1
 31c:	fc 01       	movw	r30, r24
 31e:	36 97       	sbiw	r30, 0x06	; 6
 320:	60 e8       	ldi	r22, 0x80	; 128
 322:	60 83       	st	Z, r22
 324:	fc 01       	movw	r30, r24
 326:	37 97       	sbiw	r30, 0x07	; 7
 328:	10 82       	st	Z, r1
 32a:	fc 01       	movw	r30, r24
 32c:	38 97       	sbiw	r30, 0x08	; 8
 32e:	62 e0       	ldi	r22, 0x02	; 2
 330:	60 83       	st	Z, r22
 332:	fc 01       	movw	r30, r24
 334:	39 97       	sbiw	r30, 0x09	; 9
 336:	63 e0       	ldi	r22, 0x03	; 3
 338:	60 83       	st	Z, r22
 33a:	fc 01       	movw	r30, r24
 33c:	3a 97       	sbiw	r30, 0x0a	; 10
 33e:	64 e0       	ldi	r22, 0x04	; 4
 340:	60 83       	st	Z, r22
 342:	fc 01       	movw	r30, r24
 344:	3b 97       	sbiw	r30, 0x0b	; 11
 346:	65 e0       	ldi	r22, 0x05	; 5
 348:	60 83       	st	Z, r22
 34a:	fc 01       	movw	r30, r24
 34c:	3c 97       	sbiw	r30, 0x0c	; 12
 34e:	66 e0       	ldi	r22, 0x06	; 6
 350:	60 83       	st	Z, r22
 352:	fc 01       	movw	r30, r24
 354:	3d 97       	sbiw	r30, 0x0d	; 13
 356:	67 e0       	ldi	r22, 0x07	; 7
 358:	60 83       	st	Z, r22
 35a:	fc 01       	movw	r30, r24
 35c:	3e 97       	sbiw	r30, 0x0e	; 14
 35e:	68 e0       	ldi	r22, 0x08	; 8
 360:	60 83       	st	Z, r22
 362:	fc 01       	movw	r30, r24
 364:	3f 97       	sbiw	r30, 0x0f	; 15
 366:	69 e0       	ldi	r22, 0x09	; 9
 368:	60 83       	st	Z, r22
 36a:	fc 01       	movw	r30, r24
 36c:	70 97       	sbiw	r30, 0x10	; 16
 36e:	60 e1       	ldi	r22, 0x10	; 16
 370:	60 83       	st	Z, r22
 372:	fc 01       	movw	r30, r24
 374:	71 97       	sbiw	r30, 0x11	; 17
 376:	30 83       	st	Z, r19
 378:	fc 01       	movw	r30, r24
 37a:	72 97       	sbiw	r30, 0x12	; 18
 37c:	32 e1       	ldi	r19, 0x12	; 18
 37e:	30 83       	st	Z, r19
 380:	fc 01       	movw	r30, r24
 382:	73 97       	sbiw	r30, 0x13	; 19
 384:	33 e1       	ldi	r19, 0x13	; 19
 386:	30 83       	st	Z, r19
 388:	fc 01       	movw	r30, r24
 38a:	74 97       	sbiw	r30, 0x14	; 20
 38c:	34 e1       	ldi	r19, 0x14	; 20
 38e:	30 83       	st	Z, r19
 390:	fc 01       	movw	r30, r24
 392:	75 97       	sbiw	r30, 0x15	; 21
 394:	35 e1       	ldi	r19, 0x15	; 21
 396:	30 83       	st	Z, r19
 398:	fc 01       	movw	r30, r24
 39a:	76 97       	sbiw	r30, 0x16	; 22
 39c:	36 e1       	ldi	r19, 0x16	; 22
 39e:	30 83       	st	Z, r19
 3a0:	fc 01       	movw	r30, r24
 3a2:	77 97       	sbiw	r30, 0x17	; 23
 3a4:	37 e1       	ldi	r19, 0x17	; 23
 3a6:	30 83       	st	Z, r19
 3a8:	fc 01       	movw	r30, r24
 3aa:	78 97       	sbiw	r30, 0x18	; 24
 3ac:	38 e1       	ldi	r19, 0x18	; 24
 3ae:	30 83       	st	Z, r19
 3b0:	fc 01       	movw	r30, r24
 3b2:	79 97       	sbiw	r30, 0x19	; 25
 3b4:	39 e1       	ldi	r19, 0x19	; 25
 3b6:	30 83       	st	Z, r19
 3b8:	fc 01       	movw	r30, r24
 3ba:	7a 97       	sbiw	r30, 0x1a	; 26
 3bc:	30 e2       	ldi	r19, 0x20	; 32
 3be:	30 83       	st	Z, r19
 3c0:	fc 01       	movw	r30, r24
 3c2:	7b 97       	sbiw	r30, 0x1b	; 27
 3c4:	31 e2       	ldi	r19, 0x21	; 33
 3c6:	30 83       	st	Z, r19
 3c8:	fc 01       	movw	r30, r24
 3ca:	7c 97       	sbiw	r30, 0x1c	; 28
 3cc:	20 83       	st	Z, r18
 3ce:	fc 01       	movw	r30, r24
 3d0:	7d 97       	sbiw	r30, 0x1d	; 29
 3d2:	23 e2       	ldi	r18, 0x23	; 35
 3d4:	20 83       	st	Z, r18
 3d6:	fc 01       	movw	r30, r24
 3d8:	7e 97       	sbiw	r30, 0x1e	; 30
 3da:	40 83       	st	Z, r20
 3dc:	fc 01       	movw	r30, r24
 3de:	7f 97       	sbiw	r30, 0x1f	; 31
 3e0:	50 83       	st	Z, r21
 3e2:	fc 01       	movw	r30, r24
 3e4:	b0 97       	sbiw	r30, 0x20	; 32
 3e6:	26 e2       	ldi	r18, 0x26	; 38
 3e8:	20 83       	st	Z, r18
 3ea:	fc 01       	movw	r30, r24
 3ec:	b1 97       	sbiw	r30, 0x21	; 33
 3ee:	27 e2       	ldi	r18, 0x27	; 39
 3f0:	20 83       	st	Z, r18
 3f2:	fc 01       	movw	r30, r24
 3f4:	b2 97       	sbiw	r30, 0x22	; 34
 3f6:	28 e2       	ldi	r18, 0x28	; 40
 3f8:	20 83       	st	Z, r18
 3fa:	fc 01       	movw	r30, r24
 3fc:	b3 97       	sbiw	r30, 0x23	; 35
 3fe:	29 e2       	ldi	r18, 0x29	; 41
 400:	20 83       	st	Z, r18
 402:	fc 01       	movw	r30, r24
 404:	b4 97       	sbiw	r30, 0x24	; 36
 406:	20 e3       	ldi	r18, 0x30	; 48
 408:	20 83       	st	Z, r18
 40a:	fc 01       	movw	r30, r24
 40c:	b5 97       	sbiw	r30, 0x25	; 37
 40e:	21 e3       	ldi	r18, 0x31	; 49
 410:	20 83       	st	Z, r18
 412:	9c 01       	movw	r18, r24
 414:	26 52       	subi	r18, 0x26	; 38
 416:	31 09       	sbc	r19, r1
 418:	82 2f       	mov	r24, r18
 41a:	93 2f       	mov	r25, r19
 41c:	08 95       	ret

0000041e <xPortStartScheduler>:
 41e:	1b bc       	out	0x2b, r1	; 43
 420:	89 ef       	ldi	r24, 0xF9	; 249
 422:	8a bd       	out	0x2a, r24	; 42
 424:	8b e0       	ldi	r24, 0x0B	; 11
 426:	8e bd       	out	0x2e, r24	; 46
 428:	87 b7       	in	r24, 0x37	; 55
 42a:	80 61       	ori	r24, 0x10	; 16
 42c:	87 bf       	out	0x37, r24	; 55
 42e:	a0 91 fd 06 	lds	r26, 0x06FD
 432:	b0 91 fe 06 	lds	r27, 0x06FE
 436:	cd 91       	ld	r28, X+
 438:	cd bf       	out	0x3d, r28	; 61
 43a:	dd 91       	ld	r29, X+
 43c:	de bf       	out	0x3e, r29	; 62
 43e:	ff 91       	pop	r31
 440:	ef 91       	pop	r30
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	bf 91       	pop	r27
 448:	af 91       	pop	r26
 44a:	9f 91       	pop	r25
 44c:	8f 91       	pop	r24
 44e:	7f 91       	pop	r23
 450:	6f 91       	pop	r22
 452:	5f 91       	pop	r21
 454:	4f 91       	pop	r20
 456:	3f 91       	pop	r19
 458:	2f 91       	pop	r18
 45a:	1f 91       	pop	r17
 45c:	0f 91       	pop	r16
 45e:	ff 90       	pop	r15
 460:	ef 90       	pop	r14
 462:	df 90       	pop	r13
 464:	cf 90       	pop	r12
 466:	bf 90       	pop	r11
 468:	af 90       	pop	r10
 46a:	9f 90       	pop	r9
 46c:	8f 90       	pop	r8
 46e:	7f 90       	pop	r7
 470:	6f 90       	pop	r6
 472:	5f 90       	pop	r5
 474:	4f 90       	pop	r4
 476:	3f 90       	pop	r3
 478:	2f 90       	pop	r2
 47a:	1f 90       	pop	r1
 47c:	0f 90       	pop	r0
 47e:	0f be       	out	0x3f, r0	; 63
 480:	0f 90       	pop	r0
 482:	08 95       	ret
 484:	81 e0       	ldi	r24, 0x01	; 1
 486:	08 95       	ret

00000488 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 488:	0f 92       	push	r0
 48a:	0f b6       	in	r0, 0x3f	; 63
 48c:	f8 94       	cli
 48e:	0f 92       	push	r0
 490:	1f 92       	push	r1
 492:	11 24       	eor	r1, r1
 494:	2f 92       	push	r2
 496:	3f 92       	push	r3
 498:	4f 92       	push	r4
 49a:	5f 92       	push	r5
 49c:	6f 92       	push	r6
 49e:	7f 92       	push	r7
 4a0:	8f 92       	push	r8
 4a2:	9f 92       	push	r9
 4a4:	af 92       	push	r10
 4a6:	bf 92       	push	r11
 4a8:	cf 92       	push	r12
 4aa:	df 92       	push	r13
 4ac:	ef 92       	push	r14
 4ae:	ff 92       	push	r15
 4b0:	0f 93       	push	r16
 4b2:	1f 93       	push	r17
 4b4:	2f 93       	push	r18
 4b6:	3f 93       	push	r19
 4b8:	4f 93       	push	r20
 4ba:	5f 93       	push	r21
 4bc:	6f 93       	push	r22
 4be:	7f 93       	push	r23
 4c0:	8f 93       	push	r24
 4c2:	9f 93       	push	r25
 4c4:	af 93       	push	r26
 4c6:	bf 93       	push	r27
 4c8:	cf 93       	push	r28
 4ca:	df 93       	push	r29
 4cc:	ef 93       	push	r30
 4ce:	ff 93       	push	r31
 4d0:	a0 91 fd 06 	lds	r26, 0x06FD
 4d4:	b0 91 fe 06 	lds	r27, 0x06FE
 4d8:	0d b6       	in	r0, 0x3d	; 61
 4da:	0d 92       	st	X+, r0
 4dc:	0e b6       	in	r0, 0x3e	; 62
 4de:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4e0:	8f d3       	rcall	.+1822   	; 0xc00 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4e2:	a0 91 fd 06 	lds	r26, 0x06FD
 4e6:	b0 91 fe 06 	lds	r27, 0x06FE
 4ea:	cd 91       	ld	r28, X+
 4ec:	cd bf       	out	0x3d, r28	; 61
 4ee:	dd 91       	ld	r29, X+
 4f0:	de bf       	out	0x3e, r29	; 62
 4f2:	ff 91       	pop	r31
 4f4:	ef 91       	pop	r30
 4f6:	df 91       	pop	r29
 4f8:	cf 91       	pop	r28
 4fa:	bf 91       	pop	r27
 4fc:	af 91       	pop	r26
 4fe:	9f 91       	pop	r25
 500:	8f 91       	pop	r24
 502:	7f 91       	pop	r23
 504:	6f 91       	pop	r22
 506:	5f 91       	pop	r21
 508:	4f 91       	pop	r20
 50a:	3f 91       	pop	r19
 50c:	2f 91       	pop	r18
 50e:	1f 91       	pop	r17
 510:	0f 91       	pop	r16
 512:	ff 90       	pop	r15
 514:	ef 90       	pop	r14
 516:	df 90       	pop	r13
 518:	cf 90       	pop	r12
 51a:	bf 90       	pop	r11
 51c:	af 90       	pop	r10
 51e:	9f 90       	pop	r9
 520:	8f 90       	pop	r8
 522:	7f 90       	pop	r7
 524:	6f 90       	pop	r6
 526:	5f 90       	pop	r5
 528:	4f 90       	pop	r4
 52a:	3f 90       	pop	r3
 52c:	2f 90       	pop	r2
 52e:	1f 90       	pop	r1
 530:	0f 90       	pop	r0
 532:	0f be       	out	0x3f, r0	; 63
 534:	0f 90       	pop	r0

	asm volatile ( "ret" );
 536:	08 95       	ret

00000538 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 538:	0f 92       	push	r0
 53a:	0f b6       	in	r0, 0x3f	; 63
 53c:	f8 94       	cli
 53e:	0f 92       	push	r0
 540:	1f 92       	push	r1
 542:	11 24       	eor	r1, r1
 544:	2f 92       	push	r2
 546:	3f 92       	push	r3
 548:	4f 92       	push	r4
 54a:	5f 92       	push	r5
 54c:	6f 92       	push	r6
 54e:	7f 92       	push	r7
 550:	8f 92       	push	r8
 552:	9f 92       	push	r9
 554:	af 92       	push	r10
 556:	bf 92       	push	r11
 558:	cf 92       	push	r12
 55a:	df 92       	push	r13
 55c:	ef 92       	push	r14
 55e:	ff 92       	push	r15
 560:	0f 93       	push	r16
 562:	1f 93       	push	r17
 564:	2f 93       	push	r18
 566:	3f 93       	push	r19
 568:	4f 93       	push	r20
 56a:	5f 93       	push	r21
 56c:	6f 93       	push	r22
 56e:	7f 93       	push	r23
 570:	8f 93       	push	r24
 572:	9f 93       	push	r25
 574:	af 93       	push	r26
 576:	bf 93       	push	r27
 578:	cf 93       	push	r28
 57a:	df 93       	push	r29
 57c:	ef 93       	push	r30
 57e:	ff 93       	push	r31
 580:	a0 91 fd 06 	lds	r26, 0x06FD
 584:	b0 91 fe 06 	lds	r27, 0x06FE
 588:	0d b6       	in	r0, 0x3d	; 61
 58a:	0d 92       	st	X+, r0
 58c:	0e b6       	in	r0, 0x3e	; 62
 58e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 590:	a6 d1       	rcall	.+844    	; 0x8de <xTaskIncrementTick>
 592:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 594:	35 d3       	rcall	.+1642   	; 0xc00 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 596:	a0 91 fd 06 	lds	r26, 0x06FD
 59a:	b0 91 fe 06 	lds	r27, 0x06FE
 59e:	cd 91       	ld	r28, X+
 5a0:	cd bf       	out	0x3d, r28	; 61
 5a2:	dd 91       	ld	r29, X+
 5a4:	de bf       	out	0x3e, r29	; 62
 5a6:	ff 91       	pop	r31
 5a8:	ef 91       	pop	r30
 5aa:	df 91       	pop	r29
 5ac:	cf 91       	pop	r28
 5ae:	bf 91       	pop	r27
 5b0:	af 91       	pop	r26
 5b2:	9f 91       	pop	r25
 5b4:	8f 91       	pop	r24
 5b6:	7f 91       	pop	r23
 5b8:	6f 91       	pop	r22
 5ba:	5f 91       	pop	r21
 5bc:	4f 91       	pop	r20
 5be:	3f 91       	pop	r19
 5c0:	2f 91       	pop	r18
 5c2:	1f 91       	pop	r17
 5c4:	0f 91       	pop	r16
 5c6:	ff 90       	pop	r15
 5c8:	ef 90       	pop	r14
 5ca:	df 90       	pop	r13
 5cc:	cf 90       	pop	r12
 5ce:	bf 90       	pop	r11
 5d0:	af 90       	pop	r10
 5d2:	9f 90       	pop	r9
 5d4:	8f 90       	pop	r8
 5d6:	7f 90       	pop	r7
 5d8:	6f 90       	pop	r6
 5da:	5f 90       	pop	r5
 5dc:	4f 90       	pop	r4
 5de:	3f 90       	pop	r3
 5e0:	2f 90       	pop	r2
 5e2:	1f 90       	pop	r1
 5e4:	0f 90       	pop	r0
 5e6:	0f be       	out	0x3f, r0	; 63
 5e8:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5ea:	08 95       	ret

000005ec <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 5ec:	a5 df       	rcall	.-182    	; 0x538 <vPortYieldFromTick>
		asm volatile ( "reti" );
 5ee:	18 95       	reti

000005f0 <prvAddCurrentTaskToDelayedList>:
UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
}
 5f0:	cf 93       	push	r28
 5f2:	df 93       	push	r29
 5f4:	ec 01       	movw	r28, r24
 5f6:	e0 91 fd 06 	lds	r30, 0x06FD
 5fa:	f0 91 fe 06 	lds	r31, 0x06FE
 5fe:	93 83       	std	Z+3, r25	; 0x03
 600:	82 83       	std	Z+2, r24	; 0x02
 602:	80 91 f6 06 	lds	r24, 0x06F6
 606:	90 91 f7 06 	lds	r25, 0x06F7
 60a:	c8 17       	cp	r28, r24
 60c:	d9 07       	cpc	r29, r25
 60e:	60 f4       	brcc	.+24     	; 0x628 <prvAddCurrentTaskToDelayedList+0x38>
 610:	60 91 fd 06 	lds	r22, 0x06FD
 614:	70 91 fe 06 	lds	r23, 0x06FE
 618:	80 91 f9 06 	lds	r24, 0x06F9
 61c:	90 91 fa 06 	lds	r25, 0x06FA
 620:	6e 5f       	subi	r22, 0xFE	; 254
 622:	7f 4f       	sbci	r23, 0xFF	; 255
 624:	11 de       	rcall	.-990    	; 0x248 <vListInsert>
 626:	16 c0       	rjmp	.+44     	; 0x654 <prvAddCurrentTaskToDelayedList+0x64>
 628:	60 91 fd 06 	lds	r22, 0x06FD
 62c:	70 91 fe 06 	lds	r23, 0x06FE
 630:	80 91 fb 06 	lds	r24, 0x06FB
 634:	90 91 fc 06 	lds	r25, 0x06FC
 638:	6e 5f       	subi	r22, 0xFE	; 254
 63a:	7f 4f       	sbci	r23, 0xFF	; 255
 63c:	05 de       	rcall	.-1014   	; 0x248 <vListInsert>
 63e:	80 91 00 01 	lds	r24, 0x0100
 642:	90 91 01 01 	lds	r25, 0x0101
 646:	c8 17       	cp	r28, r24
 648:	d9 07       	cpc	r29, r25
 64a:	20 f4       	brcc	.+8      	; 0x654 <prvAddCurrentTaskToDelayedList+0x64>
 64c:	d0 93 01 01 	sts	0x0101, r29
 650:	c0 93 00 01 	sts	0x0100, r28
 654:	df 91       	pop	r29
 656:	cf 91       	pop	r28
 658:	08 95       	ret

0000065a <prvIdleTask>:
 65a:	c0 e0       	ldi	r28, 0x00	; 0
 65c:	d7 e0       	ldi	r29, 0x07	; 7
 65e:	88 81       	ld	r24, Y
 660:	82 30       	cpi	r24, 0x02	; 2
 662:	10 f0       	brcs	.+4      	; 0x668 <prvIdleTask+0xe>
 664:	11 df       	rcall	.-478    	; 0x488 <vPortYield>
 666:	fb cf       	rjmp	.-10     	; 0x65e <prvIdleTask+0x4>
 668:	ff cf       	rjmp	.-2      	; 0x668 <prvIdleTask+0xe>

0000066a <xTaskGenericCreate>:
 66a:	4f 92       	push	r4
 66c:	5f 92       	push	r5
 66e:	6f 92       	push	r6
 670:	7f 92       	push	r7
 672:	8f 92       	push	r8
 674:	9f 92       	push	r9
 676:	af 92       	push	r10
 678:	bf 92       	push	r11
 67a:	cf 92       	push	r12
 67c:	df 92       	push	r13
 67e:	ef 92       	push	r14
 680:	ff 92       	push	r15
 682:	0f 93       	push	r16
 684:	1f 93       	push	r17
 686:	cf 93       	push	r28
 688:	df 93       	push	r29
 68a:	4c 01       	movw	r8, r24
 68c:	5b 01       	movw	r10, r22
 68e:	2a 01       	movw	r4, r20
 690:	39 01       	movw	r6, r18
 692:	81 e2       	ldi	r24, 0x21	; 33
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	63 dd       	rcall	.-1338   	; 0x15e <pvPortMalloc>
 698:	ec 01       	movw	r28, r24
 69a:	00 97       	sbiw	r24, 0x00	; 0
 69c:	09 f4       	brne	.+2      	; 0x6a0 <xTaskGenericCreate+0x36>
 69e:	d2 c0       	rjmp	.+420    	; 0x844 <xTaskGenericCreate+0x1da>
 6a0:	c1 14       	cp	r12, r1
 6a2:	d1 04       	cpc	r13, r1
 6a4:	09 f0       	breq	.+2      	; 0x6a8 <xTaskGenericCreate+0x3e>
 6a6:	b8 c0       	rjmp	.+368    	; 0x818 <xTaskGenericCreate+0x1ae>
 6a8:	c2 01       	movw	r24, r4
 6aa:	59 dd       	rcall	.-1358   	; 0x15e <pvPortMalloc>
 6ac:	98 8f       	std	Y+24, r25	; 0x18
 6ae:	8f 8b       	std	Y+23, r24	; 0x17
 6b0:	89 2b       	or	r24, r25
 6b2:	09 f0       	breq	.+2      	; 0x6b6 <xTaskGenericCreate+0x4c>
 6b4:	b3 c0       	rjmp	.+358    	; 0x81c <xTaskGenericCreate+0x1b2>
 6b6:	ce 01       	movw	r24, r28
 6b8:	86 dd       	rcall	.-1268   	; 0x1c6 <vPortFree>
 6ba:	c4 c0       	rjmp	.+392    	; 0x844 <xTaskGenericCreate+0x1da>
 6bc:	cf 01       	movw	r24, r30
 6be:	31 91       	ld	r19, Z+
 6c0:	da 01       	movw	r26, r20
 6c2:	3d 93       	st	X+, r19
 6c4:	ad 01       	movw	r20, r26
 6c6:	dc 01       	movw	r26, r24
 6c8:	8c 91       	ld	r24, X
 6ca:	88 23       	and	r24, r24
 6cc:	11 f0       	breq	.+4      	; 0x6d2 <xTaskGenericCreate+0x68>
 6ce:	21 50       	subi	r18, 0x01	; 1
 6d0:	a9 f7       	brne	.-22     	; 0x6bc <xTaskGenericCreate+0x52>
 6d2:	18 a2       	std	Y+32, r1	; 0x20
 6d4:	10 2f       	mov	r17, r16
 6d6:	04 30       	cpi	r16, 0x04	; 4
 6d8:	08 f0       	brcs	.+2      	; 0x6dc <xTaskGenericCreate+0x72>
 6da:	13 e0       	ldi	r17, 0x03	; 3
 6dc:	1e 8b       	std	Y+22, r17	; 0x16
 6de:	5e 01       	movw	r10, r28
 6e0:	b2 e0       	ldi	r27, 0x02	; 2
 6e2:	ab 0e       	add	r10, r27
 6e4:	b1 1c       	adc	r11, r1
 6e6:	c5 01       	movw	r24, r10
 6e8:	8a dd       	rcall	.-1260   	; 0x1fe <vListInitialiseItem>
 6ea:	ce 01       	movw	r24, r28
 6ec:	0c 96       	adiw	r24, 0x0c	; 12
 6ee:	87 dd       	rcall	.-1266   	; 0x1fe <vListInitialiseItem>
 6f0:	d9 87       	std	Y+9, r29	; 0x09
 6f2:	c8 87       	std	Y+8, r28	; 0x08
 6f4:	84 e0       	ldi	r24, 0x04	; 4
 6f6:	90 e0       	ldi	r25, 0x00	; 0
 6f8:	81 1b       	sub	r24, r17
 6fa:	91 09       	sbc	r25, r1
 6fc:	9d 87       	std	Y+13, r25	; 0x0d
 6fe:	8c 87       	std	Y+12, r24	; 0x0c
 700:	db 8b       	std	Y+19, r29	; 0x13
 702:	ca 8b       	std	Y+18, r28	; 0x12
 704:	a3 01       	movw	r20, r6
 706:	b4 01       	movw	r22, r8
 708:	c6 01       	movw	r24, r12
 70a:	f5 dd       	rcall	.-1046   	; 0x2f6 <pxPortInitialiseStack>
 70c:	99 83       	std	Y+1, r25	; 0x01
 70e:	88 83       	st	Y, r24
 710:	e1 14       	cp	r14, r1
 712:	f1 04       	cpc	r15, r1
 714:	19 f0       	breq	.+6      	; 0x71c <xTaskGenericCreate+0xb2>
 716:	f7 01       	movw	r30, r14
 718:	d1 83       	std	Z+1, r29	; 0x01
 71a:	c0 83       	st	Z, r28
 71c:	0f b6       	in	r0, 0x3f	; 63
 71e:	f8 94       	cli
 720:	0f 92       	push	r0
 722:	80 91 f8 06 	lds	r24, 0x06F8
 726:	8f 5f       	subi	r24, 0xFF	; 255
 728:	80 93 f8 06 	sts	0x06F8, r24
 72c:	80 91 fd 06 	lds	r24, 0x06FD
 730:	90 91 fe 06 	lds	r25, 0x06FE
 734:	89 2b       	or	r24, r25
 736:	99 f5       	brne	.+102    	; 0x79e <xTaskGenericCreate+0x134>
 738:	d0 93 fe 06 	sts	0x06FE, r29
 73c:	c0 93 fd 06 	sts	0x06FD, r28
 740:	80 91 f8 06 	lds	r24, 0x06F8
 744:	81 30       	cpi	r24, 0x01	; 1
 746:	d1 f5       	brne	.+116    	; 0x7bc <xTaskGenericCreate+0x152>
 748:	e1 2c       	mov	r14, r1
 74a:	f1 2c       	mov	r15, r1
 74c:	c7 01       	movw	r24, r14
 74e:	88 0f       	add	r24, r24
 750:	99 1f       	adc	r25, r25
 752:	88 0f       	add	r24, r24
 754:	99 1f       	adc	r25, r25
 756:	88 0f       	add	r24, r24
 758:	99 1f       	adc	r25, r25
 75a:	8e 0d       	add	r24, r14
 75c:	9f 1d       	adc	r25, r15
 75e:	80 50       	subi	r24, 0x00	; 0
 760:	99 4f       	sbci	r25, 0xF9	; 249
 762:	3f dd       	rcall	.-1410   	; 0x1e2 <vListInitialise>
 764:	ff ef       	ldi	r31, 0xFF	; 255
 766:	ef 1a       	sub	r14, r31
 768:	ff 0a       	sbc	r15, r31
 76a:	84 e0       	ldi	r24, 0x04	; 4
 76c:	e8 16       	cp	r14, r24
 76e:	f1 04       	cpc	r15, r1
 770:	69 f7       	brne	.-38     	; 0x74c <xTaskGenericCreate+0xe2>
 772:	84 e2       	ldi	r24, 0x24	; 36
 774:	97 e0       	ldi	r25, 0x07	; 7
 776:	35 dd       	rcall	.-1430   	; 0x1e2 <vListInitialise>
 778:	8d e2       	ldi	r24, 0x2D	; 45
 77a:	97 e0       	ldi	r25, 0x07	; 7
 77c:	32 dd       	rcall	.-1436   	; 0x1e2 <vListInitialise>
 77e:	86 e3       	ldi	r24, 0x36	; 54
 780:	97 e0       	ldi	r25, 0x07	; 7
 782:	2f dd       	rcall	.-1442   	; 0x1e2 <vListInitialise>
 784:	84 e2       	ldi	r24, 0x24	; 36
 786:	97 e0       	ldi	r25, 0x07	; 7
 788:	90 93 fc 06 	sts	0x06FC, r25
 78c:	80 93 fb 06 	sts	0x06FB, r24
 790:	8d e2       	ldi	r24, 0x2D	; 45
 792:	97 e0       	ldi	r25, 0x07	; 7
 794:	90 93 fa 06 	sts	0x06FA, r25
 798:	80 93 f9 06 	sts	0x06F9, r24
 79c:	0f c0       	rjmp	.+30     	; 0x7bc <xTaskGenericCreate+0x152>
 79e:	80 91 f4 06 	lds	r24, 0x06F4
 7a2:	81 11       	cpse	r24, r1
 7a4:	0b c0       	rjmp	.+22     	; 0x7bc <xTaskGenericCreate+0x152>
 7a6:	e0 91 fd 06 	lds	r30, 0x06FD
 7aa:	f0 91 fe 06 	lds	r31, 0x06FE
 7ae:	86 89       	ldd	r24, Z+22	; 0x16
 7b0:	08 17       	cp	r16, r24
 7b2:	20 f0       	brcs	.+8      	; 0x7bc <xTaskGenericCreate+0x152>
 7b4:	d0 93 fe 06 	sts	0x06FE, r29
 7b8:	c0 93 fd 06 	sts	0x06FD, r28
 7bc:	80 91 ff 06 	lds	r24, 0x06FF
 7c0:	8f 5f       	subi	r24, 0xFF	; 255
 7c2:	80 93 ff 06 	sts	0x06FF, r24
 7c6:	8e 89       	ldd	r24, Y+22	; 0x16
 7c8:	90 91 f5 06 	lds	r25, 0x06F5
 7cc:	98 17       	cp	r25, r24
 7ce:	10 f4       	brcc	.+4      	; 0x7d4 <xTaskGenericCreate+0x16a>
 7d0:	80 93 f5 06 	sts	0x06F5, r24
 7d4:	90 e0       	ldi	r25, 0x00	; 0
 7d6:	9c 01       	movw	r18, r24
 7d8:	22 0f       	add	r18, r18
 7da:	33 1f       	adc	r19, r19
 7dc:	22 0f       	add	r18, r18
 7de:	33 1f       	adc	r19, r19
 7e0:	22 0f       	add	r18, r18
 7e2:	33 1f       	adc	r19, r19
 7e4:	82 0f       	add	r24, r18
 7e6:	93 1f       	adc	r25, r19
 7e8:	b5 01       	movw	r22, r10
 7ea:	80 50       	subi	r24, 0x00	; 0
 7ec:	99 4f       	sbci	r25, 0xF9	; 249
 7ee:	0b dd       	rcall	.-1514   	; 0x206 <vListInsertEnd>
 7f0:	0f 90       	pop	r0
 7f2:	0f be       	out	0x3f, r0	; 63
 7f4:	80 91 f4 06 	lds	r24, 0x06F4
 7f8:	88 23       	and	r24, r24
 7fa:	51 f0       	breq	.+20     	; 0x810 <xTaskGenericCreate+0x1a6>
 7fc:	e0 91 fd 06 	lds	r30, 0x06FD
 800:	f0 91 fe 06 	lds	r31, 0x06FE
 804:	86 89       	ldd	r24, Z+22	; 0x16
 806:	80 17       	cp	r24, r16
 808:	28 f4       	brcc	.+10     	; 0x814 <xTaskGenericCreate+0x1aa>
 80a:	3e de       	rcall	.-900    	; 0x488 <vPortYield>
 80c:	81 e0       	ldi	r24, 0x01	; 1
 80e:	1b c0       	rjmp	.+54     	; 0x846 <xTaskGenericCreate+0x1dc>
 810:	81 e0       	ldi	r24, 0x01	; 1
 812:	19 c0       	rjmp	.+50     	; 0x846 <xTaskGenericCreate+0x1dc>
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	17 c0       	rjmp	.+46     	; 0x846 <xTaskGenericCreate+0x1dc>
 818:	d8 8e       	std	Y+24, r13	; 0x18
 81a:	cf 8a       	std	Y+23, r12	; 0x17
 81c:	a1 e0       	ldi	r26, 0x01	; 1
 81e:	4a 1a       	sub	r4, r26
 820:	51 08       	sbc	r5, r1
 822:	cf 88       	ldd	r12, Y+23	; 0x17
 824:	d8 8c       	ldd	r13, Y+24	; 0x18
 826:	c4 0c       	add	r12, r4
 828:	d5 1c       	adc	r13, r5
 82a:	f5 01       	movw	r30, r10
 82c:	80 81       	ld	r24, Z
 82e:	89 8f       	std	Y+25, r24	; 0x19
 830:	80 81       	ld	r24, Z
 832:	88 23       	and	r24, r24
 834:	09 f4       	brne	.+2      	; 0x838 <xTaskGenericCreate+0x1ce>
 836:	4d cf       	rjmp	.-358    	; 0x6d2 <xTaskGenericCreate+0x68>
 838:	ae 01       	movw	r20, r28
 83a:	46 5e       	subi	r20, 0xE6	; 230
 83c:	5f 4f       	sbci	r21, 0xFF	; 255
 83e:	31 96       	adiw	r30, 0x01	; 1
 840:	27 e0       	ldi	r18, 0x07	; 7
 842:	3c cf       	rjmp	.-392    	; 0x6bc <xTaskGenericCreate+0x52>
 844:	8f ef       	ldi	r24, 0xFF	; 255
 846:	df 91       	pop	r29
 848:	cf 91       	pop	r28
 84a:	1f 91       	pop	r17
 84c:	0f 91       	pop	r16
 84e:	ff 90       	pop	r15
 850:	ef 90       	pop	r14
 852:	df 90       	pop	r13
 854:	cf 90       	pop	r12
 856:	bf 90       	pop	r11
 858:	af 90       	pop	r10
 85a:	9f 90       	pop	r9
 85c:	8f 90       	pop	r8
 85e:	7f 90       	pop	r7
 860:	6f 90       	pop	r6
 862:	5f 90       	pop	r5
 864:	4f 90       	pop	r4
 866:	08 95       	ret

00000868 <vTaskStartScheduler>:
 868:	af 92       	push	r10
 86a:	bf 92       	push	r11
 86c:	cf 92       	push	r12
 86e:	df 92       	push	r13
 870:	ef 92       	push	r14
 872:	ff 92       	push	r15
 874:	0f 93       	push	r16
 876:	a1 2c       	mov	r10, r1
 878:	b1 2c       	mov	r11, r1
 87a:	c1 2c       	mov	r12, r1
 87c:	d1 2c       	mov	r13, r1
 87e:	e1 2c       	mov	r14, r1
 880:	f1 2c       	mov	r15, r1
 882:	00 e0       	ldi	r16, 0x00	; 0
 884:	20 e0       	ldi	r18, 0x00	; 0
 886:	30 e0       	ldi	r19, 0x00	; 0
 888:	45 e5       	ldi	r20, 0x55	; 85
 88a:	50 e0       	ldi	r21, 0x00	; 0
 88c:	6b e0       	ldi	r22, 0x0B	; 11
 88e:	71 e0       	ldi	r23, 0x01	; 1
 890:	8d e2       	ldi	r24, 0x2D	; 45
 892:	93 e0       	ldi	r25, 0x03	; 3
 894:	ea de       	rcall	.-556    	; 0x66a <xTaskGenericCreate>
 896:	81 30       	cpi	r24, 0x01	; 1
 898:	41 f4       	brne	.+16     	; 0x8aa <vTaskStartScheduler+0x42>
 89a:	f8 94       	cli
 89c:	80 93 f4 06 	sts	0x06F4, r24
 8a0:	10 92 f7 06 	sts	0x06F7, r1
 8a4:	10 92 f6 06 	sts	0x06F6, r1
 8a8:	ba dd       	rcall	.-1164   	; 0x41e <xPortStartScheduler>
 8aa:	0f 91       	pop	r16
 8ac:	ff 90       	pop	r15
 8ae:	ef 90       	pop	r14
 8b0:	df 90       	pop	r13
 8b2:	cf 90       	pop	r12
 8b4:	bf 90       	pop	r11
 8b6:	af 90       	pop	r10
 8b8:	08 95       	ret

000008ba <vTaskSuspendAll>:
 8ba:	80 91 f0 06 	lds	r24, 0x06F0
 8be:	8f 5f       	subi	r24, 0xFF	; 255
 8c0:	80 93 f0 06 	sts	0x06F0, r24
 8c4:	08 95       	ret

000008c6 <xTaskGetTickCount>:
 8c6:	0f b6       	in	r0, 0x3f	; 63
 8c8:	f8 94       	cli
 8ca:	0f 92       	push	r0
 8cc:	20 91 f6 06 	lds	r18, 0x06F6
 8d0:	30 91 f7 06 	lds	r19, 0x06F7
 8d4:	0f 90       	pop	r0
 8d6:	0f be       	out	0x3f, r0	; 63
 8d8:	82 2f       	mov	r24, r18
 8da:	93 2f       	mov	r25, r19
 8dc:	08 95       	ret

000008de <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8de:	cf 92       	push	r12
 8e0:	df 92       	push	r13
 8e2:	ef 92       	push	r14
 8e4:	ff 92       	push	r15
 8e6:	0f 93       	push	r16
 8e8:	1f 93       	push	r17
 8ea:	cf 93       	push	r28
 8ec:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8ee:	80 91 f0 06 	lds	r24, 0x06F0
 8f2:	81 11       	cpse	r24, r1
 8f4:	b3 c0       	rjmp	.+358    	; 0xa5c <xTaskIncrementTick+0x17e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 8f6:	80 91 f6 06 	lds	r24, 0x06F6
 8fa:	90 91 f7 06 	lds	r25, 0x06F7
 8fe:	01 96       	adiw	r24, 0x01	; 1
 900:	90 93 f7 06 	sts	0x06F7, r25
 904:	80 93 f6 06 	sts	0x06F6, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 908:	e0 90 f6 06 	lds	r14, 0x06F6
 90c:	f0 90 f7 06 	lds	r15, 0x06F7

			if( xConstTickCount == ( TickType_t ) 0U )
 910:	e1 14       	cp	r14, r1
 912:	f1 04       	cpc	r15, r1
 914:	99 f5       	brne	.+102    	; 0x97c <xTaskIncrementTick+0x9e>
			{
				taskSWITCH_DELAYED_LISTS();
 916:	80 91 fb 06 	lds	r24, 0x06FB
 91a:	90 91 fc 06 	lds	r25, 0x06FC
 91e:	20 91 f9 06 	lds	r18, 0x06F9
 922:	30 91 fa 06 	lds	r19, 0x06FA
 926:	30 93 fc 06 	sts	0x06FC, r19
 92a:	20 93 fb 06 	sts	0x06FB, r18
 92e:	90 93 fa 06 	sts	0x06FA, r25
 932:	80 93 f9 06 	sts	0x06F9, r24
 936:	80 91 f1 06 	lds	r24, 0x06F1
 93a:	8f 5f       	subi	r24, 0xFF	; 255
 93c:	80 93 f1 06 	sts	0x06F1, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 940:	e0 91 fb 06 	lds	r30, 0x06FB
 944:	f0 91 fc 06 	lds	r31, 0x06FC
 948:	80 81       	ld	r24, Z
 94a:	81 11       	cpse	r24, r1
 94c:	07 c0       	rjmp	.+14     	; 0x95c <xTaskIncrementTick+0x7e>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 94e:	8f ef       	ldi	r24, 0xFF	; 255
 950:	9f ef       	ldi	r25, 0xFF	; 255
 952:	90 93 01 01 	sts	0x0101, r25
 956:	80 93 00 01 	sts	0x0100, r24
 95a:	10 c0       	rjmp	.+32     	; 0x97c <xTaskIncrementTick+0x9e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 95c:	e0 91 fb 06 	lds	r30, 0x06FB
 960:	f0 91 fc 06 	lds	r31, 0x06FC
 964:	05 80       	ldd	r0, Z+5	; 0x05
 966:	f6 81       	ldd	r31, Z+6	; 0x06
 968:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 96a:	06 80       	ldd	r0, Z+6	; 0x06
 96c:	f7 81       	ldd	r31, Z+7	; 0x07
 96e:	e0 2d       	mov	r30, r0
 970:	82 81       	ldd	r24, Z+2	; 0x02
 972:	93 81       	ldd	r25, Z+3	; 0x03
 974:	90 93 01 01 	sts	0x0101, r25
 978:	80 93 00 01 	sts	0x0100, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 97c:	80 91 00 01 	lds	r24, 0x0100
 980:	90 91 01 01 	lds	r25, 0x0101
 984:	e8 16       	cp	r14, r24
 986:	f9 06       	cpc	r15, r25
 988:	20 f4       	brcc	.+8      	; 0x992 <xTaskIncrementTick+0xb4>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 98a:	d1 2c       	mov	r13, r1
 98c:	51 c0       	rjmp	.+162    	; 0xa30 <xTaskIncrementTick+0x152>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 98e:	dc 2c       	mov	r13, r12
 990:	03 c0       	rjmp	.+6      	; 0x998 <xTaskIncrementTick+0xba>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 992:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 994:	cc 24       	eor	r12, r12
 996:	c3 94       	inc	r12
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 998:	e0 91 fb 06 	lds	r30, 0x06FB
 99c:	f0 91 fc 06 	lds	r31, 0x06FC
 9a0:	80 81       	ld	r24, Z
 9a2:	81 11       	cpse	r24, r1
 9a4:	07 c0       	rjmp	.+14     	; 0x9b4 <xTaskIncrementTick+0xd6>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 9a6:	8f ef       	ldi	r24, 0xFF	; 255
 9a8:	9f ef       	ldi	r25, 0xFF	; 255
 9aa:	90 93 01 01 	sts	0x0101, r25
 9ae:	80 93 00 01 	sts	0x0100, r24
						break;
 9b2:	3e c0       	rjmp	.+124    	; 0xa30 <xTaskIncrementTick+0x152>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 9b4:	e0 91 fb 06 	lds	r30, 0x06FB
 9b8:	f0 91 fc 06 	lds	r31, 0x06FC
 9bc:	05 80       	ldd	r0, Z+5	; 0x05
 9be:	f6 81       	ldd	r31, Z+6	; 0x06
 9c0:	e0 2d       	mov	r30, r0
 9c2:	c6 81       	ldd	r28, Z+6	; 0x06
 9c4:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 9c6:	2a 81       	ldd	r18, Y+2	; 0x02
 9c8:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 9ca:	e2 16       	cp	r14, r18
 9cc:	f3 06       	cpc	r15, r19
 9ce:	28 f4       	brcc	.+10     	; 0x9da <xTaskIncrementTick+0xfc>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 9d0:	30 93 01 01 	sts	0x0101, r19
 9d4:	20 93 00 01 	sts	0x0100, r18
							break;
 9d8:	2b c0       	rjmp	.+86     	; 0xa30 <xTaskIncrementTick+0x152>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 9da:	8e 01       	movw	r16, r28
 9dc:	0e 5f       	subi	r16, 0xFE	; 254
 9de:	1f 4f       	sbci	r17, 0xFF	; 255
 9e0:	c8 01       	movw	r24, r16
 9e2:	63 dc       	rcall	.-1850   	; 0x2aa <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 9e4:	8c 89       	ldd	r24, Y+20	; 0x14
 9e6:	9d 89       	ldd	r25, Y+21	; 0x15
 9e8:	89 2b       	or	r24, r25
 9ea:	19 f0       	breq	.+6      	; 0x9f2 <xTaskIncrementTick+0x114>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 9ec:	ce 01       	movw	r24, r28
 9ee:	0c 96       	adiw	r24, 0x0c	; 12
 9f0:	5c dc       	rcall	.-1864   	; 0x2aa <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 9f2:	2e 89       	ldd	r18, Y+22	; 0x16
 9f4:	80 91 f5 06 	lds	r24, 0x06F5
 9f8:	82 17       	cp	r24, r18
 9fa:	10 f4       	brcc	.+4      	; 0xa00 <xTaskIncrementTick+0x122>
 9fc:	20 93 f5 06 	sts	0x06F5, r18
 a00:	30 e0       	ldi	r19, 0x00	; 0
 a02:	c9 01       	movw	r24, r18
 a04:	88 0f       	add	r24, r24
 a06:	99 1f       	adc	r25, r25
 a08:	88 0f       	add	r24, r24
 a0a:	99 1f       	adc	r25, r25
 a0c:	88 0f       	add	r24, r24
 a0e:	99 1f       	adc	r25, r25
 a10:	82 0f       	add	r24, r18
 a12:	93 1f       	adc	r25, r19
 a14:	b8 01       	movw	r22, r16
 a16:	80 50       	subi	r24, 0x00	; 0
 a18:	99 4f       	sbci	r25, 0xF9	; 249
 a1a:	f5 db       	rcall	.-2070   	; 0x206 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 a1c:	e0 91 fd 06 	lds	r30, 0x06FD
 a20:	f0 91 fe 06 	lds	r31, 0x06FE
 a24:	9e 89       	ldd	r25, Y+22	; 0x16
 a26:	86 89       	ldd	r24, Z+22	; 0x16
 a28:	98 17       	cp	r25, r24
 a2a:	08 f0       	brcs	.+2      	; 0xa2e <xTaskIncrementTick+0x150>
 a2c:	b0 cf       	rjmp	.-160    	; 0x98e <xTaskIncrementTick+0xb0>
 a2e:	b4 cf       	rjmp	.-152    	; 0x998 <xTaskIncrementTick+0xba>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 a30:	e0 91 fd 06 	lds	r30, 0x06FD
 a34:	f0 91 fe 06 	lds	r31, 0x06FE
 a38:	86 89       	ldd	r24, Z+22	; 0x16
 a3a:	90 e0       	ldi	r25, 0x00	; 0
 a3c:	fc 01       	movw	r30, r24
 a3e:	ee 0f       	add	r30, r30
 a40:	ff 1f       	adc	r31, r31
 a42:	ee 0f       	add	r30, r30
 a44:	ff 1f       	adc	r31, r31
 a46:	ee 0f       	add	r30, r30
 a48:	ff 1f       	adc	r31, r31
 a4a:	8e 0f       	add	r24, r30
 a4c:	9f 1f       	adc	r25, r31
 a4e:	fc 01       	movw	r30, r24
 a50:	e0 50       	subi	r30, 0x00	; 0
 a52:	f9 4f       	sbci	r31, 0xF9	; 249
 a54:	80 81       	ld	r24, Z
 a56:	82 30       	cpi	r24, 0x02	; 2
 a58:	40 f4       	brcc	.+16     	; 0xa6a <xTaskIncrementTick+0x18c>
 a5a:	09 c0       	rjmp	.+18     	; 0xa6e <xTaskIncrementTick+0x190>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 a5c:	80 91 f3 06 	lds	r24, 0x06F3
 a60:	8f 5f       	subi	r24, 0xFF	; 255
 a62:	80 93 f3 06 	sts	0x06F3, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a66:	d1 2c       	mov	r13, r1
 a68:	02 c0       	rjmp	.+4      	; 0xa6e <xTaskIncrementTick+0x190>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
 a6a:	dd 24       	eor	r13, r13
 a6c:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 a6e:	80 91 f2 06 	lds	r24, 0x06F2
 a72:	88 23       	and	r24, r24
 a74:	11 f0       	breq	.+4      	; 0xa7a <xTaskIncrementTick+0x19c>
		{
			xSwitchRequired = pdTRUE;
 a76:	dd 24       	eor	r13, r13
 a78:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 a7a:	8d 2d       	mov	r24, r13
 a7c:	df 91       	pop	r29
 a7e:	cf 91       	pop	r28
 a80:	1f 91       	pop	r17
 a82:	0f 91       	pop	r16
 a84:	ff 90       	pop	r15
 a86:	ef 90       	pop	r14
 a88:	df 90       	pop	r13
 a8a:	cf 90       	pop	r12
 a8c:	08 95       	ret

00000a8e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 a8e:	df 92       	push	r13
 a90:	ef 92       	push	r14
 a92:	ff 92       	push	r15
 a94:	0f 93       	push	r16
 a96:	1f 93       	push	r17
 a98:	cf 93       	push	r28
 a9a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 a9c:	0f b6       	in	r0, 0x3f	; 63
 a9e:	f8 94       	cli
 aa0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 aa2:	80 91 f0 06 	lds	r24, 0x06F0
 aa6:	81 50       	subi	r24, 0x01	; 1
 aa8:	80 93 f0 06 	sts	0x06F0, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 aac:	80 91 f0 06 	lds	r24, 0x06F0
 ab0:	81 11       	cpse	r24, r1
 ab2:	5c c0       	rjmp	.+184    	; 0xb6c <xTaskResumeAll+0xde>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 ab4:	80 91 f8 06 	lds	r24, 0x06F8
 ab8:	81 11       	cpse	r24, r1
 aba:	2f c0       	rjmp	.+94     	; 0xb1a <xTaskResumeAll+0x8c>
 abc:	5a c0       	rjmp	.+180    	; 0xb72 <xTaskResumeAll+0xe4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 abe:	e0 91 3b 07 	lds	r30, 0x073B
 ac2:	f0 91 3c 07 	lds	r31, 0x073C
 ac6:	c6 81       	ldd	r28, Z+6	; 0x06
 ac8:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 aca:	ce 01       	movw	r24, r28
 acc:	0c 96       	adiw	r24, 0x0c	; 12
 ace:	ed db       	rcall	.-2086   	; 0x2aa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 ad0:	8e 01       	movw	r16, r28
 ad2:	0e 5f       	subi	r16, 0xFE	; 254
 ad4:	1f 4f       	sbci	r17, 0xFF	; 255
 ad6:	c8 01       	movw	r24, r16
 ad8:	e8 db       	rcall	.-2096   	; 0x2aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 ada:	8e 89       	ldd	r24, Y+22	; 0x16
 adc:	90 91 f5 06 	lds	r25, 0x06F5
 ae0:	98 17       	cp	r25, r24
 ae2:	10 f4       	brcc	.+4      	; 0xae8 <xTaskResumeAll+0x5a>
 ae4:	80 93 f5 06 	sts	0x06F5, r24
 ae8:	90 e0       	ldi	r25, 0x00	; 0
 aea:	9c 01       	movw	r18, r24
 aec:	22 0f       	add	r18, r18
 aee:	33 1f       	adc	r19, r19
 af0:	22 0f       	add	r18, r18
 af2:	33 1f       	adc	r19, r19
 af4:	22 0f       	add	r18, r18
 af6:	33 1f       	adc	r19, r19
 af8:	82 0f       	add	r24, r18
 afa:	93 1f       	adc	r25, r19
 afc:	b8 01       	movw	r22, r16
 afe:	80 50       	subi	r24, 0x00	; 0
 b00:	99 4f       	sbci	r25, 0xF9	; 249
 b02:	81 db       	rcall	.-2302   	; 0x206 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 b04:	e0 91 fd 06 	lds	r30, 0x06FD
 b08:	f0 91 fe 06 	lds	r31, 0x06FE
 b0c:	9e 89       	ldd	r25, Y+22	; 0x16
 b0e:	86 89       	ldd	r24, Z+22	; 0x16
 b10:	98 17       	cp	r25, r24
 b12:	58 f0       	brcs	.+22     	; 0xb2a <xTaskResumeAll+0x9c>
					{
						xYieldPending = pdTRUE;
 b14:	d0 92 f2 06 	sts	0x06F2, r13
 b18:	08 c0       	rjmp	.+16     	; 0xb2a <xTaskResumeAll+0x9c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 b1a:	0f 2e       	mov	r0, r31
 b1c:	f6 e3       	ldi	r31, 0x36	; 54
 b1e:	ef 2e       	mov	r14, r31
 b20:	f7 e0       	ldi	r31, 0x07	; 7
 b22:	ff 2e       	mov	r15, r31
 b24:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 b26:	dd 24       	eor	r13, r13
 b28:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 b2a:	f7 01       	movw	r30, r14
 b2c:	80 81       	ld	r24, Z
 b2e:	81 11       	cpse	r24, r1
 b30:	c6 cf       	rjmp	.-116    	; 0xabe <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 b32:	80 91 f3 06 	lds	r24, 0x06F3
 b36:	88 23       	and	r24, r24
 b38:	91 f0       	breq	.+36     	; 0xb5e <xTaskResumeAll+0xd0>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 b3a:	80 91 f3 06 	lds	r24, 0x06F3
 b3e:	88 23       	and	r24, r24
 b40:	71 f0       	breq	.+28     	; 0xb5e <xTaskResumeAll+0xd0>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 b42:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 b44:	cc de       	rcall	.-616    	; 0x8de <xTaskIncrementTick>
 b46:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 b48:	c0 93 f2 06 	sts	0x06F2, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 b4c:	80 91 f3 06 	lds	r24, 0x06F3
 b50:	81 50       	subi	r24, 0x01	; 1
 b52:	80 93 f3 06 	sts	0x06F3, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 b56:	80 91 f3 06 	lds	r24, 0x06F3
 b5a:	81 11       	cpse	r24, r1
 b5c:	f3 cf       	rjmp	.-26     	; 0xb44 <xTaskResumeAll+0xb6>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 b5e:	80 91 f2 06 	lds	r24, 0x06F2
 b62:	81 30       	cpi	r24, 0x01	; 1
 b64:	29 f4       	brne	.+10     	; 0xb70 <xTaskResumeAll+0xe2>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 b66:	90 dc       	rcall	.-1760   	; 0x488 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 b68:	81 e0       	ldi	r24, 0x01	; 1
 b6a:	03 c0       	rjmp	.+6      	; 0xb72 <xTaskResumeAll+0xe4>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 b6c:	80 e0       	ldi	r24, 0x00	; 0
 b6e:	01 c0       	rjmp	.+2      	; 0xb72 <xTaskResumeAll+0xe4>
 b70:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 b72:	0f 90       	pop	r0
 b74:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 b76:	df 91       	pop	r29
 b78:	cf 91       	pop	r28
 b7a:	1f 91       	pop	r17
 b7c:	0f 91       	pop	r16
 b7e:	ff 90       	pop	r15
 b80:	ef 90       	pop	r14
 b82:	df 90       	pop	r13
 b84:	08 95       	ret

00000b86 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 b86:	0f 93       	push	r16
 b88:	1f 93       	push	r17
 b8a:	cf 93       	push	r28
 b8c:	df 93       	push	r29
 b8e:	8c 01       	movw	r16, r24
 b90:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 b92:	93 de       	rcall	.-730    	; 0x8ba <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 b94:	80 91 f6 06 	lds	r24, 0x06F6
 b98:	90 91 f7 06 	lds	r25, 0x06F7

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 b9c:	f8 01       	movw	r30, r16
 b9e:	20 81       	ld	r18, Z
 ba0:	31 81       	ldd	r19, Z+1	; 0x01
 ba2:	c2 0f       	add	r28, r18
 ba4:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
 ba6:	82 17       	cp	r24, r18
 ba8:	93 07       	cpc	r25, r19
 baa:	48 f4       	brcc	.+18     	; 0xbbe <vTaskDelayUntil+0x38>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 bac:	c2 17       	cp	r28, r18
 bae:	d3 07       	cpc	r29, r19
 bb0:	f0 f4       	brcc	.+60     	; 0xbee <vTaskDelayUntil+0x68>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 bb2:	d1 83       	std	Z+1, r29	; 0x01
 bb4:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
 bb6:	8c 17       	cp	r24, r28
 bb8:	9d 07       	cpc	r25, r29
 bba:	80 f4       	brcc	.+32     	; 0xbdc <vTaskDelayUntil+0x56>
 bbc:	07 c0       	rjmp	.+14     	; 0xbcc <vTaskDelayUntil+0x46>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 bbe:	c2 17       	cp	r28, r18
 bc0:	d3 07       	cpc	r29, r19
 bc2:	88 f0       	brcs	.+34     	; 0xbe6 <vTaskDelayUntil+0x60>
 bc4:	8c 17       	cp	r24, r28
 bc6:	9d 07       	cpc	r25, r29
 bc8:	70 f0       	brcs	.+28     	; 0xbe6 <vTaskDelayUntil+0x60>
 bca:	11 c0       	rjmp	.+34     	; 0xbee <vTaskDelayUntil+0x68>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 bcc:	80 91 fd 06 	lds	r24, 0x06FD
 bd0:	90 91 fe 06 	lds	r25, 0x06FE
 bd4:	02 96       	adiw	r24, 0x02	; 2
 bd6:	69 db       	rcall	.-2350   	; 0x2aa <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 bd8:	ce 01       	movw	r24, r28
 bda:	0a dd       	rcall	.-1516   	; 0x5f0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 bdc:	58 df       	rcall	.-336    	; 0xa8e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 bde:	81 11       	cpse	r24, r1
 be0:	0a c0       	rjmp	.+20     	; 0xbf6 <vTaskDelayUntil+0x70>
		{
			portYIELD_WITHIN_API();
 be2:	52 dc       	rcall	.-1884   	; 0x488 <vPortYield>
 be4:	08 c0       	rjmp	.+16     	; 0xbf6 <vTaskDelayUntil+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 be6:	f8 01       	movw	r30, r16
 be8:	d1 83       	std	Z+1, r29	; 0x01
 bea:	c0 83       	st	Z, r28
 bec:	ef cf       	rjmp	.-34     	; 0xbcc <vTaskDelayUntil+0x46>
 bee:	f8 01       	movw	r30, r16
 bf0:	d1 83       	std	Z+1, r29	; 0x01
 bf2:	c0 83       	st	Z, r28
 bf4:	f3 cf       	rjmp	.-26     	; 0xbdc <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 bf6:	df 91       	pop	r29
 bf8:	cf 91       	pop	r28
 bfa:	1f 91       	pop	r17
 bfc:	0f 91       	pop	r16
 bfe:	08 95       	ret

00000c00 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c00:	80 91 f0 06 	lds	r24, 0x06F0
 c04:	88 23       	and	r24, r24
 c06:	21 f0       	breq	.+8      	; 0xc10 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c08:	81 e0       	ldi	r24, 0x01	; 1
 c0a:	80 93 f2 06 	sts	0x06F2, r24
 c0e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 c10:	10 92 f2 06 	sts	0x06F2, r1
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
 c14:	80 91 f5 06 	lds	r24, 0x06F5
 c18:	90 e0       	ldi	r25, 0x00	; 0
 c1a:	fc 01       	movw	r30, r24
 c1c:	ee 0f       	add	r30, r30
 c1e:	ff 1f       	adc	r31, r31
 c20:	ee 0f       	add	r30, r30
 c22:	ff 1f       	adc	r31, r31
 c24:	ee 0f       	add	r30, r30
 c26:	ff 1f       	adc	r31, r31
 c28:	8e 0f       	add	r24, r30
 c2a:	9f 1f       	adc	r25, r31
 c2c:	fc 01       	movw	r30, r24
 c2e:	e0 50       	subi	r30, 0x00	; 0
 c30:	f9 4f       	sbci	r31, 0xF9	; 249
 c32:	80 81       	ld	r24, Z
 c34:	81 11       	cpse	r24, r1
 c36:	17 c0       	rjmp	.+46     	; 0xc66 <vTaskSwitchContext+0x66>
 c38:	80 91 f5 06 	lds	r24, 0x06F5
 c3c:	81 50       	subi	r24, 0x01	; 1
 c3e:	80 93 f5 06 	sts	0x06F5, r24
 c42:	80 91 f5 06 	lds	r24, 0x06F5
 c46:	90 e0       	ldi	r25, 0x00	; 0
 c48:	fc 01       	movw	r30, r24
 c4a:	ee 0f       	add	r30, r30
 c4c:	ff 1f       	adc	r31, r31
 c4e:	ee 0f       	add	r30, r30
 c50:	ff 1f       	adc	r31, r31
 c52:	ee 0f       	add	r30, r30
 c54:	ff 1f       	adc	r31, r31
 c56:	8e 0f       	add	r24, r30
 c58:	9f 1f       	adc	r25, r31
 c5a:	fc 01       	movw	r30, r24
 c5c:	e0 50       	subi	r30, 0x00	; 0
 c5e:	f9 4f       	sbci	r31, 0xF9	; 249
 c60:	80 81       	ld	r24, Z
 c62:	88 23       	and	r24, r24
 c64:	49 f3       	breq	.-46     	; 0xc38 <vTaskSwitchContext+0x38>
 c66:	e0 91 f5 06 	lds	r30, 0x06F5
 c6a:	f0 e0       	ldi	r31, 0x00	; 0
 c6c:	cf 01       	movw	r24, r30
 c6e:	88 0f       	add	r24, r24
 c70:	99 1f       	adc	r25, r25
 c72:	88 0f       	add	r24, r24
 c74:	99 1f       	adc	r25, r25
 c76:	88 0f       	add	r24, r24
 c78:	99 1f       	adc	r25, r25
 c7a:	e8 0f       	add	r30, r24
 c7c:	f9 1f       	adc	r31, r25
 c7e:	e0 50       	subi	r30, 0x00	; 0
 c80:	f9 4f       	sbci	r31, 0xF9	; 249
 c82:	a1 81       	ldd	r26, Z+1	; 0x01
 c84:	b2 81       	ldd	r27, Z+2	; 0x02
 c86:	12 96       	adiw	r26, 0x02	; 2
 c88:	0d 90       	ld	r0, X+
 c8a:	bc 91       	ld	r27, X
 c8c:	a0 2d       	mov	r26, r0
 c8e:	b2 83       	std	Z+2, r27	; 0x02
 c90:	a1 83       	std	Z+1, r26	; 0x01
 c92:	cf 01       	movw	r24, r30
 c94:	03 96       	adiw	r24, 0x03	; 3
 c96:	a8 17       	cp	r26, r24
 c98:	b9 07       	cpc	r27, r25
 c9a:	31 f4       	brne	.+12     	; 0xca8 <vTaskSwitchContext+0xa8>
 c9c:	12 96       	adiw	r26, 0x02	; 2
 c9e:	8d 91       	ld	r24, X+
 ca0:	9c 91       	ld	r25, X
 ca2:	13 97       	sbiw	r26, 0x03	; 3
 ca4:	92 83       	std	Z+2, r25	; 0x02
 ca6:	81 83       	std	Z+1, r24	; 0x01
 ca8:	01 80       	ldd	r0, Z+1	; 0x01
 caa:	f2 81       	ldd	r31, Z+2	; 0x02
 cac:	e0 2d       	mov	r30, r0
 cae:	86 81       	ldd	r24, Z+6	; 0x06
 cb0:	97 81       	ldd	r25, Z+7	; 0x07
 cb2:	90 93 fe 06 	sts	0x06FE, r25
 cb6:	80 93 fd 06 	sts	0x06FD, r24
 cba:	08 95       	ret

00000cbc <_exit>:
 cbc:	f8 94       	cli

00000cbe <__stop_program>:
 cbe:	ff cf       	rjmp	.-2      	; 0xcbe <__stop_program>
